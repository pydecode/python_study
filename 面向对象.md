# 类的设计
1. **类名** 这类事物的名字，满足大驼峰命名法
2. **属性** 这类事物具有什么的特征
3. **方法** 这类事物具有什么样的行为

## 大驼峰命名法
'CapWords'
1. 每个单词的首字母大写
2. 单词与单词之间没有下划线

## 类名的确定
名词提炼法 分析整个业务流程，出现的名词通常就是找到的类
## 属性和方法的确定
- 对象的特征描述，通常可以定义成属性
- 对象具有的行为（动词）通常可以定义成方法

> 提示：需求中没有涉及到的属性或者方法在设计类时，不需要考虑

# 面向对象的基础语法 
## 定义类
```python

class 类名()：
def 方法1（self,参数列表）:
pass
```
## 创建对象
```
对象变量 = 类名（）
```

# 由哪个对象调用的方法，方法内self就是哪个对象的引用
> 类的属性定义
```
self.属性名 = 形参
```
# 身份运算符
> 身份运算符用于**比较**两个内存地址是否一致是否对同一对象的引用

+ 在python中针对None比较时，建议使用is判断

| 运算符 | 描述                                     |               实例               |
| ------ | ---------------------------------------- | :------------------------------: |
| is     | 判断两个标识符是不是引用同一个对象       |    x is y ，类似id(x) = id(y)    |
| is not | 判断两个标识符是不是引用**不同**一个对象 | x in not y , 类似 id(a)！= id(b) |

# is 与 == 区别
> is 用于判断两个变量引用对象是否为同一个
> == 用于判断**引用变量的值**是否相等

# 私有属性和私有方法
+ 在实际开发中，对象的某些属性或方法可能只希望在对象的内部被使用，面不希望在外部被访问到
+ 私有属性就是对象不希望公开的 **属性**
+ 私有方法就是对象不希望公开的 **方法**

定义方式
- 在定义属性或方法时，在属性名或者方法名前增加两个下划线，定义就是私有属性或方法

```
class Fun(object):

    def __init__(self, name):
        self.__name = name
        sefl.age = 18

fun = Fun('kali')
print(fun.name)

```
`self.__name 是不可以在外部被访问的 `

`self.age 是可以在外部被访问的`

# 伪私有属性和么有方法
> 提示：在日常开发中，不要用这种方式访问对象的私有属性或方法
> python 中并没有真**真正意义**的私有
- 在给属性、方法 命名时，实际是对名称做了一些特殊处理，使得外界无法访问到
- python解释器的处理方法：就是在 **名称** 前面加上 _类名 => _类名__名称

```
class Fun(object):
    
    def __init__(self, name):
        self.__name = name
        self.__age = 18
        print(self.__name)
      
    def __man(self):
        self.name = "body"
        print(self.name)
fun = Fun('TOM')
fun._Fun__man()
print(fun._Fun__age)
```
`_Fun__age 就是类名加属性名`
`_Fun__man()方法的外部访问方式`

# 方法的重写
+ **子类** 拥有**父类**的所有方法和属性
+ **子类**继承自父类，可又直接享受父类中已经封装好的方法
+ 当**父类**的方法不能满足子类的需求时，可又对方法进行**重写**
- 重写父类方法有两种情况
+ 1. **覆盖**父类的方法
+ 2. 对父类方法进行**扩展**

```python
# 覆盖父类的方法
# 在子类中定义一个与父类同名的方法，再改写即可
class Dog(object):
    
    def dos(self):
        print('旺旺……')
        
class Cat(Dog):
    
    def cat(self):
        print('喵喵……')

    def dos(self):
        print('哼哼……')

pig = Cat()
pig.dos()
```

 这样父类的方法就会被覆盖了，那如何在重写父类方法的同时也调用父类的方法
 在需要的位置使用 super().父类方法 来调用

```python
class Dog(object):
    
    def dos(self):
        print('旺旺……')
        
class Cat(Dog):
    
    def cat(self):
        print('喵喵……')
    
    def dos(self):
        print('哼哼……')
        
        super.dos()
        Dog.dos(self) # 这时python2.x的调用方法，python3.x还支持这种调用 
```

`super.dos()就是调用了父类方法 dos() `

`父类名.方法（self）`



